
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Route Discovery &mdash; Caravel-Transit 1.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Caravel-Transit 1.1 documentation" href="../index.html" />
    <link rel="up" title="Design Notes" href="index.html" />
    <link rel="next" title="Implementation" href="../implementation/index.html" />
    <link rel="prev" title="Arrival Detail Enrichment" href="arrival_processing.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../implementation/index.html" title="Implementation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="arrival_processing.html" title="Arrival Detail Enrichment"
             accesskey="P">previous</a> |</li>
        <li><a href="../caravel.html">Caravel-Transit 1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Design Notes</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="route-discovery">
<span id="design-routes"></span><h1>Route Discovery<a class="headerlink" href="#route-discovery" title="Permalink to this headline">¶</a></h1>
<p>The routes can be discovered from historical location report data.
Each Dwell and Arrival report contains Route, Direction, Stop and Time
information.</p>
<p>Each report is effectively a triple, <img class="math" src="../_images/math/984373e56e94542ca48fba29fc57dcd1e1bada33.png" alt="\langle v, p, t \rangle"/>, with
vehicle, <em>v</em>, the
position, <em>p</em>,
and the time, <em>t</em>.  The position breaks down into a triple, also,
<img class="math" src="../_images/math/74582fe52dace1515d0439e7776bd5a6b7aa0656.png" alt="p = \langle r, d, s \rangle"/>; this is route, <em>r</em>, direction, <em>d</em> and stop, <em>s</em>.
We can say <img class="math" src="../_images/math/601557d6fd65b67992ed0f7599b77f6183614012.png" alt="p.r"/> to reference just the route id within a position.
We&#8217;ll often summarize the position as a RDS or R/D/S triple.</p>
<p>The time has a number of attributes: <img class="math" src="../_images/math/f0e3d71488b03ccc3660f9813d10c04a0c2f4da8.png" alt="t.d"/> is the date;
<img class="math" src="../_images/math/79dcea0de2feafd4ad76c9bc1a34cf967e69f1b1.png" alt="t.w"/> is the day of the week; <img class="math" src="../_images/math/93989092c457f31960c5f564185ae32709ee3009.png" alt="t.t"/> is time of day.</p>
<p>The universe of data, is set of reports, <img class="math" src="../_images/math/eff43e84f8a3bcf7b6965f0a3248bc4d3a9d0cd4.png" alt="R"/>.</p>
<div class="math">
<p><img src="../_images/math/f8c100dc2c2fad40d339ab9706f7be8060aae4a6.png" alt="R = \{ \langle v_0, p_0, t_0 \rangle, \langle v_1, p_1, t_1 \rangle, \dotsc \}"/></p>
</div><div class="section" id="finding-scheduled-stops">
<h2>Finding Scheduled Stops<a class="headerlink" href="#finding-scheduled-stops" title="Permalink to this headline">¶</a></h2>
<p>For each position, <img class="math" src="../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>, we have a subset of the universe of reports, <img class="math" src="../_images/math/eff43e84f8a3bcf7b6965f0a3248bc4d3a9d0cd4.png" alt="R"/>, for that position</p>
<div class="math">
<p><img src="../_images/math/61af78e3623e48520f1dd7fb85cb083b18127c5f.png" alt="T_p = \{ t_n \vert \langle v_n, p_n, t_n \rangle \in R \land p_n = p \}"/></p>
</div><p>This position data does not include vehicle information, since we&#8217;re only
trying to locate stops along a route and the schedule.</p>
<p>We can partition the position data, <img class="math" src="../_images/math/3e491952b676db6942353d75fc8bd8e4e97f7016.png" alt="T_p"/>, into one-day slices.
For each day, <img class="math" src="../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/>, from the domain of available dates,
<img class="math" src="../_images/math/5410713dd7c834b8040a948ced57dc3d6a022bf6.png" alt="d \in \{ t_n.d \vert t_n \in T_p\}"/>, we have this:</p>
<div class="math">
<p><img src="../_images/math/9a326e4aebd1bd96b7a382d91fce58583662193c.png" alt="T_{p,d} = \langle t_n.t \vert  t_n \in T_p \land t_n.d = d \rangle"/></p>
</div><p>Note that <img class="math" src="../_images/math/7b9116a8cc71d95050244a53ad3cc0902726190b.png" alt="T_{p,d}"/> is a vector of stop times at this position.
Each index value is an arrival counter.  A vehicle will arrive a position
several times during the day.</p>
<p>A specific arrival time
during the day is <img class="math" src="../_images/math/1187540f108021d76856d440ac64b53ac569bf1c.png" alt="T_{p,d,k}"/>.  The value is simply a number of seconds past
some epochal time, like midnight.</p>
<p>There are <img class="math" src="../_images/math/4df8e6369ae45fc127462b39e6bbd402dcadc46b.png" alt="s = \lvert T_{p,d} \rvert"/> scheduled times because
a vehicle stops at position <img class="math" src="../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/> a total of <img class="math" src="../_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> times on a given day, <img class="math" src="../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/>.</p>
<p>Each day of the week should have a similar ordered sequence of arrival timestamps.
There&#8217;s no <em>a priori</em> reason to separate the schedule into weekday and weekend.
It&#8217;s simpler to treat each of the seven weekdays as distinct.</p>
<p>We have a
collection of
sequential stop times, <img class="math" src="../_images/math/a9d319dd4754a84cb94511cf904cea872cf234cf.png" alt="0 \leq y &lt; s"/>, on each day, <img class="math" src="../_images/math/9ac164e745f99ce53ea32ef5e68873534e320015.png" alt="0 \leq y &lt; d"/>, for the given position, <img class="math" src="../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>.</p>
<div class="math">
<p><img src="../_images/math/c19d5ad55d188567aa58d6b4ba9839eeae7a1b8b.png" alt="T_{p,y=0} &amp;= \langle T_{p,0,0}, T_{p,1,0}, \dotsc, T_{p,s-1,0} \rangle \\
T_{p,y=1} &amp;= \langle T_{p,0,1}, T_{p,1,1}, \dotsc, T_{p,s-1,1} \rangle \\
T_{p,y=2} &amp;= \langle T_{p,0,2}, T_{p,1,2}, \dotsc, T_{p,s-1,2} \rangle \\
\dotsb \\
T_{p,y=d-1} &amp;= \langle T_{p,0,d-1}, T_{p,1,d-1}, \dotsc, T_{p,s-1,d-1} \rangle"/></p>
</div><p>We can compute a mean (and other descriptive statistics) &#8220;down the colum&#8221; to get a
set of average arrival times throughout a given day.  These are the <img class="math" src="../_images/math/008e5ee4c304509b31b4d649abb7c7ba21988cdc.png" alt="T_{p,x,w_n}"/>
values for a given stop, <img class="math" src="../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>, and sequential visit, <img class="math" src="../_images/math/83664accc69abd076484c7d1da1893852242b97f.png" alt="0 \leq x &lt; s"/>.</p>
<p>If the data was complete and consistent, this would be relatively easy to
work this.  Pragmatically, there may be gaps (and duplicates) in each vector.  We&#8217;ll
address that below in the <a class="reference internal" href="#clustering">Clustering</a> section.</p>
<p>We have to count only the valid data; we&#8217;ll use <img class="math" src="../_images/math/84036c0933b351b13f4ab8beaf0291c3840119cd.png" alt="\lvert T_{p,x,y} \rvert"/> as
the &#8220;valid count&#8221;.  Ideally, all <img class="math" src="../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/> values down the column are valid, but pragmatically,
there may be duplications or omissions.</p>
<p>Each distinct arrival sequence number, <img class="math" src="../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"/>, will have an average arrival,
<img class="math" src="../_images/math/e38d1a371797c1fe145ae1cef1ca0d94f6f32d10.png" alt="\mu_{p,x}"/>, as
well as a standard deviation, <img class="math" src="../_images/math/577047c55e7bb61064573025479c2687f61fa1c1.png" alt="\sigma_{p,x}"/>.</p>
<div class="math">
<p><img src="../_images/math/93f13fd27b31e242867254852e40b437fafbcb96.png" alt="\mu_{p,x} = \mu\{T_{p,x,y} \vert 0 \leq y &lt; d\} = \frac{\sum_y{T_{p,x,y}}}{\lvert T_{p,x,y} \rvert}"/></p>
</div><div class="math">
<p><img src="../_images/math/aed814f19801b1acbb0e1561a5ce89a7a11a819c.png" alt="\sigma_{p,x} = \sigma\{T_{p,x,y} \vert 0 \leq y &lt; d\} = \sqrt{\frac{1}{\lvert T_{p,x,y} \rvert-1}\sum_d{(T_{p,x,y}-\mu_{p,x})^2}}"/></p>
</div><p>The average arrival time, <img class="math" src="../_images/math/e38d1a371797c1fe145ae1cef1ca0d94f6f32d10.png" alt="\mu_{p,x}"/>, isn&#8217;t sufficient.  The standard
deviation, <img class="math" src="../_images/math/577047c55e7bb61064573025479c2687f61fa1c1.png" alt="\sigma_{p,x}"/> is required to put a sensible confidence interval
around the arrival time.</p>
<p>Assuming that the arrival times follow a normal distribution, the following
should be true.</p>
<ul class="simple">
<li>60% of arrivals will be within <img class="math" src="../_images/math/21428949c5abe657aac9a29e8e72ba74438a3d4b.png" alt="\mu_{p,x} \pm \sigma_{p,x}"/></li>
<li>95% of arrivals will be within <img class="math" src="../_images/math/acf6a6a16d966c73618d084506d0530da8e4c40d.png" alt="\mu_{p,x} \pm 2\times\sigma_{p,x}"/></li>
<li>99% of arrivals will be within <img class="math" src="../_images/math/245d070cfdce7982c42bd708328ef0f71709a83e.png" alt="\mu_{p,x} \pm 3\times\sigma_{p,x}"/></li>
</ul>
</div>
<div class="section" id="clustering">
<h2>Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h2>
<p>Pragmatically, data may be missing or inconsistent.  The matrix will have
gaps that must be handled gracefully.  The column of data must be adjusted
to assure that all of the time values are within a &#8220;reasonable&#8221; time window
of each other.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Reasonable</p>
<p class="last">A large statistical sample will allow a formal definition of &#8220;reasonable&#8221;.</p>
</div>
<p>There may be missing data in the collection of times.  What we actually
have is the following kind of matrix of stop times with <img class="math" src="../_images/math/3b777a79f19daf5ed262a89d36871485f63781cb.png" alt="\varnothing"/>
missing data.</p>
<div class="math">
<p><img src="../_images/math/843d45479525b5fb04a8fb900d076bb317c1f0bb.png" alt="T_p = \begin{vmatrix}
T_{p,0,0} &amp; T_{p,1,0} &amp; \varnothing &amp; \dots &amp; T_{p,s-1,0} \\
\varnothing &amp; T_{p,1,1} &amp; T_{p,2,1} &amp; \dots &amp; T_{p,s-1,1} \\
T_{p,0,2} &amp; \varnothing &amp; T_{p,2,2} &amp; \dots &amp; T_{p,s-1,2} \\
\dotsb \\
T_{p,0,d-1} &amp; T_{p,1,d-1} &amp; T_{p,2,d-1} &amp; \dots &amp; T_{p,s-1,d-1} \\
\end{vmatrix}"/></p>
</div><p>The sequence of stops is shown horizontally from <img class="math" src="../_images/math/83664accc69abd076484c7d1da1893852242b97f.png" alt="0 \leq x &lt; s"/>.
The various days, <img class="math" src="../_images/math/9ac164e745f99ce53ea32ef5e68873534e320015.png" alt="0 \leq y &lt; d"/>, are shown vertically.</p>
<p>There may also be duplicates.  These are trivial to detect and exclude, so we won&#8217;t
discuss them further.</p>
<p>This can be handled by an algorithm which clusters the arrival times.
This algorithm will allow for missing reports of arrival times.</p>
<p>The goal is to minimize the deviations in the clusters of arrival times.</p>
<p>Stated another way, any other clustering of times will
yield a larger deviation value.  If we have two clusters, <img class="math" src="../_images/math/7e1b83750d0fc0a557bbc008721ccd33803d9e89.png" alt="C_7 = \{ \text{6:59}, \text{7:00} \}"/>
and <img class="math" src="../_images/math/3dc04b74b8aff0fe4e92d438ef1d4294785ae6ed.png" alt="C_8 = \{ \text{8:05}, \text{8:07} \}"/>,
and a time, <img class="math" src="../_images/math/e511a97b228d10119464869e8f4c91e320b37c6f.png" alt="T = \text{7:02}"/>.   It&#8217;s clear that <img class="math" src="../_images/math/c04ff144cd3b4093081ed9577a9702622ac49b4f.png" alt="\sigma (C_7 \cup T) &lt; \sigma (C_8 \cup T)"/>.
Therefore, the new time belongs with <img class="math" src="../_images/math/f4d08d23b84f7f83490c5cb53e381495d8e6b75a.png" alt="C_7"/>.</p>
<p>We can formalize this goal to state that each deviation is the minimum of all
alternative assignements of time to cluster.</p>
<div class="math">
<p><img src="../_images/math/0031945fb7724df5060bec8359a061dde639ed23.png" alt="\forall T_{p,x,y} \bigl( T_{p,x,y} \in C_i \land \sigma C_i = min \{ \sigma (C_j \cup T_{p,x,y}) \vert j \neq i \} \bigr)"/></p>
</div><p>Interestingly, it&#8217;s trivial to acheive this by simply claiming that each cluster
has only one arrival time.  This leads to another constraint on the clusters.</p>
<p>The additional goal is to minimize the number of clusters, consistent with a &#8220;reasonable&#8221;
arrival time window.  If we combine times to  reduce the number of clusters,
we&#8217;d have arrival times that
deviate too far from the planned schedule.</p>
<p>We can formalize this goal as a minimal number of clusters; or alternatively, an
upper limit on the deviation allowed within a cluster.  Over some <img class="math" src="../_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/>,
the cluster must be divided.</p>
<div class="math">
<p><img src="../_images/math/871827a897acffeba03f2542cb5e534d7c8dbb09.png" alt="\forall C_i \bigl( \sigma C_i &lt; \epsilon \bigr)"/></p>
</div><p>We can separate times to reduce the
deviation (and increase the number of clusters).  This allows us to make somewhat
more sensistive analyses of actual arrival times, different from the planned
schedule.  For instance, railroad crossing delays, tunnel delays and bridge
opening delays may happen at a predictable time of day.  This may mean that
a stop which is &#8220;normally&#8221; at 2:00 PM may deviate consistently to 2:05 PM on
certain days.  In a single cluster, this has a large deviation.  In separate
clusters, this has a much smaller deviation, and may be more useful for predicting
arrival times.</p>
<p><strong>Clustering Algorithm</strong>.</p>
<p><strong>[Initialization]</strong>.  Start with a sequence
of visits to a stop, <img class="math" src="../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>, to seed the clusters.
Since the choice doesn&#8217;t matter, we&#8217;ll
use the first sequence, <img class="math" src="../_images/math/988c6190c3e0174b5887eb3f598a3a3da2fb4997.png" alt="T_{p,w_0} = \langle T_{p,0,w_0}, T_{p,1,w_0}, T_{p,2,w_0}, \dotsc, T_{p,s-1,w_0} \rangle"/>
as a candidate definition of the sequence of times.</p>
<p>This creates an initial sequence of stop top clusters.
Each cluster is a single time.</p>
<div class="math">
<p><img src="../_images/math/133fec5601ff64b7dc077019ecbb06b747cfafa0.png" alt="C \gets \langle  C_0, C_1, C_2, \dotsc, C_{s-1} \rangle"/></p>
</div><p>Where</p>
<div class="math">
<p><img src="../_images/math/2d65d4faaa9f8601d3cab04d12a4906357cafe80.png" alt="C_0 &amp;= \{ T_{p,0,w_0} \} \\
C_1 &amp;= \{ T_{p,1,w_0} \} \\
C_2 &amp;= \{ T_{p,2,w_0} \} \\
\dotsb \\
C_{s-1} &amp;= \{ T_{p,s-1,w_0} \}"/></p>
</div><p>Given this initial definition,
each subsequent day of data can be matched to the candidate list of clusters.</p>
<p><strong>[Iterate through Days]</strong>.
For each day&#8217;s data, match each time with the accumulated cluster of times,
and update the clusters.</p>
<p>The next day&#8217;s data is <img class="math" src="../_images/math/71ea11f384f60af3cfdaa87765615e017570e54d.png" alt="T_{p,y} = \langle T_{p,0,y}, T_{p,1,y}, T_{p,2,y}, \dotsc, T_{p,s-1,y} \rangle"/>.</p>
<blockquote>
<div><p><strong>[Iterate through Stops]</strong>.  Each day has multiple stops, which are individually
merged into the candidate clusters.</p>
<blockquote>
<div><p><strong>[Compute Deviations]</strong>.
A brute force approach matches the new stop time, <img class="math" src="../_images/math/5312996fa6b488a97dfb5d3dc555721268803bd2.png" alt="T_{p,x,y}"/>,
against all candidate stop time clusters to compute deviation values.</p>
<div class="math">
<p><img src="../_images/math/275815b28a1cae767ce04d3d5be759037c3cbac9.png" alt="D \gets \bigl\{ \sigma(C_i \cup \{ T_{p,x,y} \}) \vert C_i \in C \bigr\}"/></p>
</div><p><strong>[Minimum</strong>].  Get index of the minimum value.</p>
<div class="math">
<p><img src="../_images/math/c7c6fbfe650ff8d7de92fc06208831e23e6eaedf.png" alt="m \gets i \vert C_i = \min D"/></p>
</div><p>The minimum <img class="math" src="../_images/math/ab1a5a03a5c38a3d71d8d640f0bf95782580b1e8.png" alt="\sigma(C_m \cup \{ T_{p,x,y} \})"/> value shows that the
new time belongs to stop <img class="math" src="../_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m"/>.</p>
<p>Ideally, the sequence of stop numbers in each day&#8217;s vectors are the same, meaning that <img class="math" src="../_images/math/095f2602fa92085e1a7845955b9dcf60f3eb9e5c.png" alt="\sigma(C_x \cup \{ T_{p,x,y} \})"/>
has the minimal value. This isn&#8217;t necessary; so it&#8217;s possible that <img class="math" src="../_images/math/bfae4bb5b503e5abec8fa43882c2f40850dfce8f.png" alt="m \neq x"/>.</p>
<p><strong>[Update Clusters]</strong>.
There are two outcomes from examination of the deviation values.</p>
<ul>
<li><p class="first">If the minimal devaition is reasonably small, <img class="math" src="../_images/math/edd02dcc7fe1af3f3f5ae42a627f9a1a40fc0662.png" alt="\sigma(C_m \cup \{ T_{p,x,y} \}) &lt; \epsilon"/>,
this new time, <img class="math" src="../_images/math/5312996fa6b488a97dfb5d3dc555721268803bd2.png" alt="T_{p,x,y}"/>,  is then appended to the <img class="math" src="../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/> cluster of times
in the sequence of stops.</p>
<div class="math">
<p><img src="../_images/math/edb34ee81d85eb99f9f15563b59579ba90f9797f.png" alt="C^{\prime} = \langle C_0, C_1, \dotsc, C_m \cup \{ T_{p,x,y} \}, \dotsc, C_{s-1} \rangle"/></p>
</div></li>
<li><p class="first">If the minimal deviation is not small enough, <img class="math" src="../_images/math/19bd0f4261f986232f063a22bde42c40c9ef7f3b.png" alt="\sigma(C_m \cup \{ T_{p,x,y} \}) \geq \epsilon"/>,
this new time is used to seed a new cluster.  It represents a gap in the previously
clustered times.</p>
<div class="math">
<p><img src="../_images/math/f7e6362c574f303ce529e33679f0ded56c2d7669.png" alt="C^{\prime} = \langle C_0, C_1, \dotsc, C_i, \{ T_{p,x,y} \}, C_{i+1}, \dotsc, C_{s-1} \rangle"/></p>
</div><p>This maintains the sorted ordering, also.</p>
<div class="math">
<p><img src="../_images/math/f7c65839a55f42e2ee62620a36d528abe05e8240.png" alt="\max(C_i) &lt; T_{p,x,y} &lt; \min(C_{i+1})"/></p>
</div></li>
</ul>
<p>In both cases, we have established that <img class="math" src="../_images/math/4cf38478c2a74b542b145d39886b623f4820376c.png" alt="\sigma C_m = min \{ \sigma (C_j \cup T_{p,x,y}) \vert j \neq m \}"/>.
The cluster creates a sequence of minimal deviations.  And the number of clusters in  <img class="math" src="../_images/math/8719862f13b63f924f182b682c6615733f3871f9.png" alt="C^{\prime}"/>
is the minimal number of clusters that will assure that the deviations are all less than <img class="math" src="../_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/>.</p>
<p>This new collection of clusters is used for the next stop time.</p>
<div class="math">
<p><img src="../_images/math/14707a0dd021ccf7ef893b68b25972cd0e6c7448.png" alt="C \gets C^{\prime}"/></p>
</div></div></blockquote>
<p><strong>[End of Stops in a Day]</strong>.  All <img class="math" src="../_images/math/a7eb055dd796dd30366462a7aea87548e4adc4aa.png" alt="T_{p,y}"/> have been merged in <img class="math" src="../_images/math/c3355896da590fc491a10150a50416687626d7cc.png" alt="C"/>.</p>
</div></blockquote>
<p><strong>[End of Days]</strong>.  All <img class="math" src="../_images/math/f89a192bc9dfd2424836fd9e3e5bb2b1cfb6ad64.png" alt="T_{p}"/> have been merged in <img class="math" src="../_images/math/c3355896da590fc491a10150a50416687626d7cc.png" alt="C"/>.
All times of all days have been assigned to clusters by finding the minimal deviation.</p>
<p>Note that some clusters may have only one time.  This can happen with outlier times
that don&#8217;t fit the &#8220;reasonably small&#8221; <img class="math" src="../_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/>.  A post-processing
pass can be used to reassess any singletons and align them into a more appropriate
cluster.</p>
<p>We should be able to assert the following:</p>
<div class="math">
<p><img src="../_images/math/6acb61fc95c0e4eb9e27a7bcc8dc49417336dce9.png" alt="\forall T_{p,x,y} &amp;\bigl( T_{p,x,y} \in C_i \land \sigma C_i = min \{ \sigma (C_j \cup T_{p,x,y}) \vert j \neq i \} \bigr)\\
\forall C_i &amp;\bigl( \sigma C_i &lt; \epsilon \bigr)"/></p>
</div><p>All deviation assignments are minimized.  Any change to the allocation of an arrival time will
lead to a cluster with a larger deviation than the above assignment.  Also, the number of
clusters is minimized.  Any additional cluster most have a deviation larger than <img class="math" src="../_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/>.</p>
<p>Barring dramatic changes in the route, the sequence of values may reflect a consistent
ordering.  This may lead to an optimization to check only <strong>adjacent</strong> stops.</p>
<p>Rather than simply compute all <img class="math" src="../_images/math/c75dd73e9662e4fc2cd3fbfe4513d07bf71080fe.png" alt="\bigl\{ \sigma (C_i \cup \{T_{p,x,y}\}) \vert C_i \in C \bigr\}"/>,
it&#8217;s easier to compute using <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/> adjacent stops.</p>
<div class="math">
<p><img src="../_images/math/2a41469126c6b94c7dbf993c04234f94d72cd431.png" alt="D \gets \bigl\{ \sigma (C_i \cup \{T_{p,x,y}\}) \vert C_i \in C \land x-k \leq i &lt; x+k \bigr\}"/></p>
</div><p>Of course, this can be optimized so that the first value that passes the
<img class="math" src="../_images/math/aa77b59ce864b246a1566e9c7c9830ac90cc1822.png" alt="\sigma(C_{x\pm k} \cup \{ T_{p,x,y} \}) &lt; \epsilon"/> test stops the
processing.</p>
</div>
<div class="section" id="finding-route-repetition">
<h2>Finding Route Repetition<a class="headerlink" href="#finding-route-repetition" title="Permalink to this headline">¶</a></h2>
<p>A route is simply a sequence of stops for a particular vehicle.  Generally,
it repeats throughout the day.</p>
<p>A given vehicle, <img class="math" src="../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>, participates in a set of stops</p>
<div class="math">
<p><img src="../_images/math/d8d228b317b4e1f1803be2acd6589489e79f6366.png" alt="PT_v = \{ \langle p_n, t_n \rangle \vert \langle v_n, p_n, t_n \rangle \in R \land v_n = v \}"/></p>
</div><p>This can be analyzed as an ordered sequence of stops.</p>
<p>We can use a least time, <img class="math" src="../_images/math/e055a1da91b8e9b26c6faea735ab41eb9294f7fb.png" alt="t_n = \min T_v = \forall_{x \in T_v} t_n \leq x"/>,
as a filter for the first instance of a sequence of stops.</p>
<div class="math">
<p><img src="../_images/math/ee922df8efb623ef739119f0d3c32051d70887f3.png" alt="\lfloor P_v \rfloor = \langle p_n \vert \langle v_n, p_n, t_n \rangle \in PT_v \land t_n = \min T_v \rangle"/></p>
</div><p>The next repeat of this route will have the same vector, but the times will all be offset
from the previous time
by approximately the same amount, <img class="math" src="../_images/math/1c60f811cdd502c2cb753b8d2c07be01bc86f408.png" alt="\delta r"/>.  We can define a filter function,
<img class="math" src="../_images/math/a82f94b2b9cd6cd99732d6b986ffce223cc96f12.png" alt="\rho( PT_v, \delta r )"/> that uses  <img class="math" src="../_images/math/7305e33d42085692e876f68a09bef056b3abc2f4.png" alt="\lfloor P_v \rfloor"/> and the offset to
locate the next repeat of the route.</p>
<div class="math">
<p><img src="../_images/math/0e6a8f3b668afd64e92de9ca18eb74d039210ea9.png" alt="\rho( PT_v, \delta r ) = \langle p_n \vert \langle v_n, p_n, t_n \rangle \in PT_v \land t^{\prime}_n = {\lfloor P_v \rfloor}_n \land t_n \approx t^{\prime}_n + \delta r \rangle"/></p>
</div><p>This generalizes nicely for any integer number of repeats of the route.</p>
<div class="math">
<p><img src="../_images/math/c86c46f1c5bf4b69d90393d29a48ddce083d6de6.png" alt="\rho( PT_v, k \delta r ) = \langle p_n \vert \langle v_n, p_n, t_n \rangle \in PT_v \land t^{\prime}_n = {\lfloor P_v \rfloor}_n \land t_n \approx t^{\prime}_n + k \delta r \rangle"/></p>
</div><p>Finding repeats of a route, however, isn&#8217;t very valuable.</p>
<p>Some routes have times that vary throughout the day to reflect the
morning and evening rush.  It&#8217;s easier (and more accurate) to ignore
repetition in the routes and treat the entire day&#8217;s schedule as one
long sequence of stops.</p>
</div>
<div class="section" id="sample-data">
<h2>Sample Data<a class="headerlink" href="#sample-data" title="Permalink to this headline">¶</a></h2>
<p>Here&#8217;s a typical sequence of data.  This listing has a number of
<tt class="docutils literal"><span class="pre">route,</span> <span class="pre">direction,</span> <span class="pre">stop</span> <span class="pre">('time</span> <span class="pre">dwell',...)</span></tt> instances.</p>
<div class="highlight-python"><pre>26 1  31 ('07:04:56 97', '14:04:28 104')
26 1  45 ('07:20:15 None',)
26 1 134 ('09:21:32 561',)
26 1 140 ('09:31:27 10',)
26 2  46 ('07:20:24 9',)
26 2 221 ('11:13:57 None',)
27 1 381 ('09:45:47 None',)
27 1 458 ('10:46:38 11',)
27 1 1188 ('19:53:29 None',)
27 2 147 ('07:05:26 44',)
27 2 333 ('09:21:18 442',)
27 2 335 ('09:20:34 None', '09:20:34 None')
27 2 481 ('11:12:17 56',)
27 2 717 ('14:04:46 45',)</pre>
</div>
<p>This shows three features.</p>
<ul class="simple">
<li>Route 26, direction 1, stop 31 was visited twice.  This is a scheduled stop.
Each day, the approximate sequence times will repeat.</li>
<li>Route 27, direction 2, stop 335 got duplicate reports.  This happens.</li>
<li>Route 26, direction 1, stop 45 (among many others) was missing.
In this case,
the various samples analyzed had time gaps.  Pragmatically, missing
data must be tolerated.</li>
</ul>
</div>
<div class="section" id="spike-solution">
<h2>Spike Solution<a class="headerlink" href="#spike-solution" title="Permalink to this headline">¶</a></h2>
<p>Here&#8217;s a named tuple that&#8217;s used to simulate Arrival-like reports.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Report</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span> <span class="s">&quot;Report&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="s">&quot;time&quot;</span><span class="p">,</span> <span class="s">&quot;rte&quot;</span><span class="p">,</span> <span class="s">&quot;dir&quot;</span><span class="p">,</span> <span class="s">&quot;stop&quot;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Here&#8217;s a method to generate a set of data that reasonably matches the
raw data.</p>
<dl class="function">
<dt id="test.spike_stats.synth_data_iter">
<tt class="descclassname">test.spike_stats.</tt><tt class="descname">synth_data_iter</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/test/spike_stats.html#synth_data_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#test.spike_stats.synth_data_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize data for route discovery.</p>
<p>This generates data for two routes.  Each route will have four stops.
Data is generated over 24 &#8220;days&#8221;, each day has a different
permutation of omitted Arrival data in the schedule.</p>
<p>For a given route, 24 days of data are generated; each day has a different
permutation of missing data.</p>
<p>For a given day of a given route, four cycles are generated. This assures
that all permutations are used.  More cycles would repeat permutations.
Fewer cycles would omit permutations.</p>
<p>The stop id number orders are randomized.  For each route, both directions
are created.  For this example, they are precise reciprocals.</p>
<p>The arrival times are generally about 10 minutes (600 seconds) apart.
A random factor of <img class="math" src="../_images/math/25638d110d7ae64adc9112310f5b836b25e00467.png" alt="\pm 60"/> is used to make sure times aren&#8217;t simple
repeats.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">iterator over Report instances.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="test.spike_stats.group_by_rte_dir_stop">
<tt class="descclassname">test.spike_stats.</tt><tt class="descname">group_by_rte_dir_stop</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/test/spike_stats.html#group_by_rte_dir_stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#test.spike_stats.group_by_rte_dir_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Since the GPS reports are in time order, we need to parition them
by route/direction/stop and date.</p>
<p>This creates a RDS (Route/Direction/Stop) dictionay that
contains each day&#8217;s times.</p>
<div class="highlight-python"><pre>{ (1,2,3): { 10/11/12: (7:08, 8:09, 9:10), 10/12/12: (7:09, 8:08) },
  (1,2,4): { 10/11/12: (7:18, 8:19, 9:20), 10/12/12: (7:19, 8:18) },
}</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; An iterable of <tt class="xref py py-class docutils literal"><span class="pre">Report</span></tt> instances.  Usually <tt class="xref py py-func docutils literal"><span class="pre">synth_data_iter()</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Dictionary keyed by Route/Direction/Stop.  Each value in that
is a dictionary keyed by day.  Each value is a time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="test.spike_stats.cluster_times">
<tt class="descclassname">test.spike_stats.</tt><tt class="descname">cluster_times</tt><big>(</big><em>reports</em>, <em>epsilon=480</em><big>)</big><a class="reference internal" href="../_modules/test/spike_stats.html#cluster_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#test.spike_stats.cluster_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlate arrival times across the various days in the data set to
create a cluster of times for each R/D/S with a minimal deviation.</p>
<p>For a given route/direction/stop, step through each day&#8217;s arrival
times at that stop.  These times are spread throughout the day, based
on various trips around the route.</p>
<p>Assume that the first day&#8217;s reported times reflect the scheduled visit times.
Build a &#8220;visits&#8221; sequence.  Each element of this sequence is a sublist
of actual times.  Initially, the sublists only have a sigle time.</p>
<p>For each day after the first:</p>
<ul class="simple">
<li>For each stop in that day:<ul>
<li>For each cluster of assumed visit times (initially based on the first day).
(Note that this is inefficient; we should use just a few adjacent clusters).<ul>
<li>Compute the standad deviation of the cluster of assumed visit times,
using the new stop as the mean time.</li>
</ul>
</li>
<li>The cluster of assumed visit times which has the smallest deviation
gets this new time assigned to it.</li>
<li>If the deviations are all &#8220;large&#8221;, then this is a new visit time that
doesn&#8217;t correlate with any of the times seen so far.
(For example, the first day was incomplete.)
Create a new assumed visit time for this
stop.  The cluster has this outlier time in it.</li>
</ul>
</li>
</ul>
<p>When all days have been examined for a given R/D/S combination, the sequence
of visit times has clusters that <em>should</em> match the official bus schedule.</p>
<p>Each cluster is reduced to a mean and a standard deviation.  This shows the
&#8220;expected&#8221; arrival time and provides a statistical window for boundary times.</p>
<p>This sequence of expected arrival and standard deviations form the schedule for
a given Route/Direction/Stop during the day.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reports</strong> &#8211; A dictionary of dictionaries.  The top key is R/D/S.  Each
inner dictionary is keyed by date and has a list of times.
See <tt class="xref py py-func docutils literal"><span class="pre">group_by_rte_dir_stop()</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A sequence of ((R/D/S), Time Sequence) tuples.  The Time Sequence
contains an ordered list of (mean, standard deviation) 2-tuples for each
arrival time at the route/direction/stop.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="test.spike_stats.build_route">
<tt class="descclassname">test.spike_stats.</tt><tt class="descname">build_route</tt><big>(</big><em>schedule</em><big>)</big><a class="reference internal" href="../_modules/test/spike_stats.html#build_route"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#test.spike_stats.build_route" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the route/direction summary as a sequence of stops throughout
the day.  This is a small reorganization of the R/D/S schedule
information to be a dictionary, keyed by R/D with a sequence of time-ordered stops.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>schedule</strong> &#8211; An iterator over 2-tuples of (R,D,S) and ( (time,std), (time,std), ... )</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dictionary with keys of (R,D) and values of ( (S,Time,Std), ... )</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="test.spike_stats.main">
<tt class="descclassname">test.spike_stats.</tt><tt class="descname">main</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/test/spike_stats.html#main"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#test.spike_stats.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Demonstrate the essential three-step route discovery algorithm.</p>
<ol class="arabic simple">
<li>Organize raw data by route/direction/stop.  <tt class="xref py py-func docutils literal"><span class="pre">group_by_rte_dir_stop()</span></tt>.</li>
<li>Correlate times to discover repeat visits to a stop.  <tt class="xref py py-func docutils literal"><span class="pre">cluster_times()</span></tt>.</li>
<li>Transform to a route/direction structure with a time-ordered
sequence of stops that spans the entire day.  <tt class="xref py py-func docutils literal"><span class="pre">build_route()</span></tt>.</li>
</ol>
</dd></dl>

</div>
<div class="section" id="optimizations">
<h2>Optimizations<a class="headerlink" href="#optimizations" title="Permalink to this headline">¶</a></h2>
<p>The Spike solution needs a few improvements.</p>
<p>It uses a brute-force match when clustering stops.  This should be a search
of adjacent stops.</p>
<p>It has an arbitrary threshold for clustering.</p>
<p>It does not do a singleton-removal pass after clustering.</p>
<p>The initial grouping by route/direction/stop should be used to create
an ordered dictionary so that all
subsequent steps can be simple generators without additional sorting or
dictionary construction.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../caravel.html">
              <img class="logo" src="../_static/Caravel2_(PSF).png" alt="Logo"/>
            </a></p>
  <h3><a href="../caravel.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Route Discovery</a><ul>
<li><a class="reference internal" href="#finding-scheduled-stops">Finding Scheduled Stops</a></li>
<li><a class="reference internal" href="#clustering">Clustering</a></li>
<li><a class="reference internal" href="#finding-route-repetition">Finding Route Repetition</a></li>
<li><a class="reference internal" href="#sample-data">Sample Data</a></li>
<li><a class="reference internal" href="#spike-solution">Spike Solution</a></li>
<li><a class="reference internal" href="#optimizations">Optimizations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="arrival_processing.html"
                        title="previous chapter">Arrival Detail Enrichment</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../implementation/index.html"
                        title="next chapter">Implementation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/design/route_details.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../implementation/index.html" title="Implementation"
             >next</a> |</li>
        <li class="right" >
          <a href="arrival_processing.html" title="Arrival Detail Enrichment"
             >previous</a> |</li>
        <li><a href="../caravel.html">Caravel-Transit 1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Design Notes</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, S.Lott.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>